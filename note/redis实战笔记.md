## 持久化选项

- 快照：把存在某一时刻的所有数据写入硬盘里面。
- 只追加文件（aof：append-only file）：它会在执行写命令时，将被执行的写命令复制到硬盘里面。



这两种持久化方法，默认都是开启的，配合使用效果更佳。



## 快照

### 触发生成快照的情况

- 配置文件的save项：举例

  ```
   save 60 10000
  ```

   这个是默认的配置。含义是：在60s内有10000个写命令，那么就会触发快照的生成

- redis从服务器第一次salveof master，会想master发送sync命令，会触发master服务器的快照生成

- 客户端发送bgsave命令到redis

- redis通过shutdown命令退出，会执行save命令，阻塞所有的客户端连接

### 执行生成快照的代价

- save命令会阻塞客户端的所有操作，直到生成快照文件完成
- bgsave命令会阻塞一段时间（fork子线程的时间，子线程负责生成快照文件）

### BGSAVE耗时

- 对于真实硬件（非阿里云等机器），redis进程每占用一个GB，fork子线程增加10~20毫秒
- 对于Xen虚拟机（云厂商的机器）,redis进程每占用一个GB，fork子线程增加200-400毫秒



## AOF

### 怎么开启

redis配置文件设置为yes

```
appendonly yes
appednsync everysec
```

**appednsync**

- always 每次写命令都刷盘
- everysec 每s刷盘 推荐
- no 等待操作系统调度。不推荐

### 存在问题

aof的文件是快照的几倍，如果一直写入可能会写满整个磁盘，并且aof文件在奔溃后恢复较慢

**重写AOF文件缓解文件过大问题**

```
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

那么当aof文件大于64mb，并且文件大小比上一次重写之后的体积大了100%时。redis将执行BGREWRITEAOF命令。

执行BGREWRITEAOF也需要fork子线程，存在与生成快照类似的问题

## 系统崩溃的后果

- 只使用快照模式：那么会丢失最近一次快照后的数据。（引发数据一致性问题？关键在于分清什么是可以缓存的，什么是不能缓存的）
- aof模式：如果刷盘模式是everysec，name只会丢1s的数据，或者不丢



## 复制

```
slaveof host port 成为从服务器
slave no one 成为主服务器，暂停更新
```



### 从服务器连接主服务器时的步骤

| 步骤 | master                                                       | slave                                                        |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | 等待命令                                                     | 连接主服务器，发送sync命令                                   |
| 2    | fork线程，执行bgsave，并在缓冲区记录BGSAVE之后执行的所有写命令 | 根据配置处理请求，或者拒绝                                   |
| 3    | 执行BGSAVE完成，发送快照文件，继续在缓冲区记录写命令         | 丢弃所有旧数据，开始载入快照文件                             |
| 4    | 快照文件发送完毕                                             | 完成对快照文件解释，开始接受命令请求                         |
| 5.   | 缓冲区的写命令发送完毕。现在开始，每一个写命令都向从服务器发送一个相同的 | 执行主服务器发来的缓冲区命令。并从现在开始接收并执行主服务器发来的每个写命令 |

